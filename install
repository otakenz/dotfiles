#!/usr/bin/env bash
# Usage:
#   ./install          # Clone my dotfiles
#   LOCAL=1 ./install  # Copy the local dotfiles directory instead of cloning
#
#   # Customize which dotfiles URL to clone from
#   DOTFILES_URL="https://github.com/example/dotfiles" ./install

set -o errexit

SKIP_SYSTEM_PACKAGES="${1:-}"

ONLY_UPDATE=

PACMAN_PACKAGES="
  aspell
  base
  base-devel
  bat
  bc
  curl
  delta
  eza
  fastfetch
  fd
  fzf
  git
  gitui
  gnupg
  htop
  inotify-tools
  jq
  lazygit
  less
  man-db
  man-pages
  mise
  neovim
  openbsd-netcat
  openssh
  pacman-contrib
  pass
  pwgen
  ripgrep
  rsync
  shellcheck
  shfmt
  tmux
  unzip
  wget
  whois
  wl-clipboard
  zip
  zsh
  zoxide
"

DEBIAN_PACKAGES="
  aspell
  bc
  build-essential
  curl
  git
  gnupg
  htop
  inotify-tools
  iproute2
  netcat-openbsd
  openssh-server
  pass
  pwgen
  rsync
  tmux
  unzip
  wget
  whois
  wl-clipboard
  xz-utils
  zip
  zsh
"

BREW_PACKAGES="
  aspell
  bash
  curl
  fastfetch
  gc
  diffutils
  git
  gnupg
  htop
  inotify-tools
  mise
  openssh
  pass
  pwgen
  rsync
  tmux
  unzip
  wget
  xz
  zsh
"
MISE_PACKAGES_ARCH=""

MISE_PACKAGES_DEBIAN="
  bat
  delta
  dust
  eza
  fd
  fzf
  gitui
  lazygit
  jq
  neovim
  ripgrep
  shellcheck
  shfmt
  zoxide
"

MISE_PACKAGES_MACOS=""

# Used to configure git
NAME=
EMAIL=

declare -A MISE_LANGUAGES
MISE_LANGUAGES=(
  ["node"]="node@22.14"
  ["python"]="python@3.13"
  ["go"]="go@1.23.8"
  ["lua"]="lua@5.4.7"
  ["rust"]="rust@1.86.0"
)

CPU_ARCH="$(uname -m)"
OS_TYPE="$(uname | tr "[:upper:]" "[:lower:]")"
OS_DISTRO=
OS_IN_WSL=

DOTFILES_URL="${DOTFILES_URL:-https://github.com/otakenz/dotfiles}"
DOTFILES_PATH="${DOTFILES_PATH:-}"

SSH_INSTRUCTIONS=
SSH_PUBKEY=

GPG_INSTRUCTIONS=
GPG_PUBKEY=

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

_error() {
  local message="${1:-}"

  printf "\e[31;1mERROR:\e[0m %s\n\n" "${message}" >&2
  exit 1
}

_info() {
  local message="${1:-}"
  printf "\n\n\e[36;1m%s:\e[0m\n\n" "${message}"
}

_local_only() {
  [ -z "${LOCAL}" ] && return 1

  if [ "${PWD}" != "${DOTFILES_PATH}" ]; then
    cp -R "${PWD}/." "${DOTFILES_PATH}"

    # Ensure the containerized environment starts fresh.
    if [ -n "${IN_CONTAINER}" ]; then
      rm \
        "${DOTFILES_PATH}/.config/zsh/.zsh_history" \
        "${DOTFILES_PATH}/.config/zsh/.aliases.local" \
        "${DOTFILES_PATH}/.config/zsh/.zprofile.local" \
        "${DOTFILES_PATH}/.config/zsh/.zshrc.local" \
        "${DOTFILES_PATH}/.config/git/config.local"

      if grep -q "git@github.com:" "${DOTFILES_PATH}/.git/config"; then
        sed -i "s|git@github.com:|https://github.com/|g" "${DOTFILES_PATH}/.git/config"
      fi
    fi
  fi

  printf "They've been locally copied to '%s'\n" "${DOTFILES_PATH}"
}

_no_system_packages() {
  cat <<EOF
System package installation isn't supported with your distro (${OS_DISTRO})

Please install any comparable packages on your own, you can view the list at:

    https://github.com/otakenz/dotfiles/blob/master/install

Then re-run this script and explicitly skip installing system packages:

    bash <(curl -sS https://raw.githubusercontent.com/otakenz/dotfiles/master/install) --skip-system-packages
EOF

  exit 1
}

_install_packages_arch() {
  # shellcheck disable=SC2086
  sudo pacman -Syu --noconfirm ${PACMAN_PACKAGES}
}

_install_packages_debian() {
  # shellcheck disable=SC2086
  sudo apt-get update && sudo apt-get install -y ${DEBIAN_PACKAGES}

  # Install Mise.
  if ! command -v mise &>/dev/null; then
    curl https://mise.run | sh
  else
    echo "Mise is already installed"
  fi

  # Install packages manually since they don't exist elsewhere.
  [ -d "$HOME/.fzf-git.sh" ] || git clone https://github.com/junegunn/fzf-git.sh.git ~/.fzf-git.sh
  printf "Installing fzf-git.sh ...\n\n"

  # fastfetch, Debian 13 / Ubuntu 26.04 LTS will have it in apt by default.
  echo
  curl -fsSL https://github.com/fastfetch-cli/fastfetch/releases/latest/download/fastfetch-linux-amd64.deb -o /tmp/fastfetch.deb
  sudo dpkg -i "${_}"
  rm "${_}"
}

_install_packages_macos() {
  local prefix="/opt/homebrew"
  [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"

  # Ensure brew's paths are available for this script
  eval "$(${prefix}/bin/brew shellenv)"

  # shellcheck disable=SC2086
  brew install ${BREW_PACKAGES}
}

_display_packages_output() {
  local packages="${1:-}"
  local mise="${3:-}"

  if [ -n "${packages}" ]; then
    echo ":: Packages (default)"
    echo -n "${packages}"
  fi

  if [ -n "${mise}" ]; then
    echo ":: Mise (default)"
    echo -n "${mise}"
  fi
}

_display_packages() {
  if [ "${OS_TYPE}" == "linux" ]; then
    if [ "${OS_DISTRO}" == "arch" ]; then
      _display_packages_output "${PACMAN_PACKAGES}" "${MISE_PACKAGES_ARCH}"
    elif [ "${OS_DISTRO}" == "debian" ]; then
      _display_packages_output "${DEBIAN_PACKAGES}" "${MISE_PACKAGES_DEBIAN}"
    fi
  else
    _display_packages_output "${BREW_PACKAGES}" "${MISE_PACKAGES_MACOS}"
  fi
}

_backup_and_symlink() {
  local src_path="$1"
  local dest_path="$2"
  local use_sudo="$3"
  local timestamp
  local BACKUP_DIR="${HOME}/.dotfiles_backup"
  local backup_dirname
  local relative_path
  local backup_path

  # Generate timestamp for backup directory
  timestamp=$(date "+%Y-%m-%d_%H-%M-%S")
  local timestamped_backup_dir="${BACKUP_DIR}/backup_${timestamp}"

  echo "${timestamped_backup_dir}"

  # Create backup directory
  mkdir -p "$timestamped_backup_dir" || {
    echo "Error: Unable to create backup directory."
    return 1
  }

  # Determine relative path of destination for backup
  relative_path="${dest_path#"${HOME}/"}"
  backup_path="${timestamped_backup_dir}/${relative_path}"
  backup_dirname=$(dirname "$backup_path")

  # Backup existing file if it exists
  if [ -e "$dest_path" ]; then
    # Resolve the real path the symlink points to
    real_target=$(realpath "$dest_path")
    echo "Resolved to: $real_target"

    if [ -d "$dest_path" ]; then
      # Ensure parent directories exist for backup
      mkdir -p "$backup_path" || {
        echo "Error: Unable to create parent directory for backup: $backup_path"
        return 1
      }
      # If the destination is a directory, copy its contents to the backup path
      cp -a "$real_target"/. "$backup_path"/
      echo "Contents copied from $real_target to $backup_path"
    else
      # Ensure parent directories exist for backup
      mkdir -p "$backup_dirname" || {
        echo "Error: Unable to create parent directory for backup: $backup_dirname"
        return 1
      }
      # If the destination is a file, copy it to the backup path
      cp -a "$real_target" "$backup_dirname"
      echo "File copied from $real_target to $backup_dirname"
    fi

  else
    echo "Warning: $dest_path does not exist, no backup made."
  fi

  # Create the symlink
  echo "🔗 Creating symlink: ln -fs \"$src_path\" \"$dest_path\""
  # shellcheck disable=SC2086
  if ${use_sudo:+sudo} ln -fs $src_path "$dest_path"; then
    if [ -L "$dest_path" ] && [ -e "$dest_path" ]; then
      echo "Symlink created successfully."
    else
      echo "Symlink created but points to a non-existent target."
    fi
  else
    echo "Error: Failed to create symlink."
    return 1
  fi
}

_get_win_users_path() {
  for base in /mnt/c/Users /c/Users; do
    [ -d "$base" ] || continue
    for path in "$base"/*; do
      user=$path
      [[ -d "$path" && ! "$user" =~ (Public|Default|All\ Users) ]] && echo "Found window user $user"
    done
    return
  done
}

_check_shell_type() {
  if [[ "$SHELL" != *zsh ]]; then
    echo "This install script requires Zsh as default shell"
    echo
    echo "💡 To make Zsh your default shell, run:"
    echo "    chsh -s $(which zsh)"
    echo
    echo "Then log out and log back in for the change to take effect."
    exit 1
  fi
}

# -----------------------------------------------------------------------------
# Main functions
# -----------------------------------------------------------------------------

detect_env() {
  if [[ ! -t 0 ]]; then
    export NON_INTERACTIVE=true
  else
    export NON_INTERACTIVE=false
  fi

  case "${OS_TYPE}" in
  linux)
    if [ -r /etc/os-release ]; then
      # shellcheck disable=SC1091
      OS_DISTRO="$(. /etc/os-release && echo "${ID_LIKE:-${ID}}")"

      # Technically ID_LIKE can have a space separated list of distros but
      # we really only care that we have a Debian based system where apt is
      # available to use.
      [[ "${OS_DISTRO}" =~ (ubuntu|debian) ]] && OS_DISTRO="debian"
    fi

    # Only fully support these Linux distros.
    if [[ -z "${OS_DISTRO}" || ! "arch ubuntu debian raspbian" =~ ${OS_DISTRO} ]]; then
      [ -z "${SKIP_SYSTEM_PACKAGES}" ] && _no_system_packages
    fi

    # Are we in WSL2 ?
    if grep -q "\-WSL2" /proc/version; then
      OS_IN_WSL=1
    fi

    # Adjust packages depending on which display server is in use.
    if [[ -z "${WAYLAND_DISPLAY}" ]]; then
      DEBIAN_PACKAGES="${DEBIAN_PACKAGES//wl-clipboard/xclip}"
      PACMAN_PACKAGES="${PACMAN_PACKAGES//wl-clipboard/xclip}"
    fi

    ;;
  darwin) ;;
  *)
    _error "'${OS_TYPE}' is not supported"

    ;;
  esac
}

warn_root() {
  # Root will have an effective uid of 0, but it's ok if we're in a container.
  [[ "${EUID}" != 0 || -n "${IN_CONTAINER}" ]] && return 0

  cat <<EOF
Here are details about this user:

$(id)

EOF

  local msg="as root"
  [[ -n "${SUDO_USER}" ]] && msg="with sudo as ${SUDO_USER}"

  while true; do
    read -rp "This script is meant to run as a non-root user, are you sure you want to run this ${msg}? (y/n) " yn
    case "${yn}" in
    [Yy]*) break ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

update_dotfiles() {
  _info "UPDATE DOTFILES"

  if [ -z "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since this is the first time you've run this script"
    return 0
  fi

  _local_only && return 0

  git -C "${DOTFILES_PATH}" fetch origin

  local new_commit_count=
  new_commit_count="$(git -C "${DOTFILES_PATH}" rev-list ..origin --count)"

  if [ "${new_commit_count}" = "0" ]; then
    echo "Skipping, since your local dotfiles already have the latest updates"
  else
    # Let's merge the latest updates.
    git -C "${DOTFILES_PATH}" merge origin

    # Re-run this script because if an update happened, it's possible new
    # packages are meant to be installed which means reading in their env vars.
    exec "${0}" "${@}"
  fi
}

check_prereqs() {
  _info "CHECKING SYSTEM COMPATABILITY"

  local missing_packages=()

  if ! command -v "sudo" 1>/dev/null; then missing_packages+=("sudo"); fi

  if [[ -z "${missing_packages[*]}" ]]; then
    echo "Everything is good to go"
    return 0
  fi

  cat <<EOF
This script is going to switch to the root user to install sudo then the rest
of the script will run as your user and use sudo as needed.

EOF

  case "${OS_DISTRO}" in
  arch)
    su -c "pacman -Syu --noconfirm ${missing_packages[*]}"
    ;;
  debian)
    su -c "apt-get update && apt-get install -y ${missing_packages[*]}"
    ;;
  *) ;;
  esac
}

create_initial_dirs() {
  mkdir -p "${HOME}/.config/tmux/plugins" "${HOME}/.config/git" \
    "${HOME}/.config/wezterm" "${HOME}/.config/zsh" "${HOME}/.config/bat"

  mkdir -p "${HOME}/.cache/zsh" "${HOME}/.local/bin" "${HOME}/.local/share/fonts"
}

install_packages() {
  _info "INSTALL PACKAGES"

  if [ -n "${SKIP_SYSTEM_PACKAGES}" ]; then
    echo "Skipping, you've chosen not to or your distro isn't fully supported"
    return
  fi

  cat <<EOF
If you choose y, all of the system packages below will be installed:

$(_display_packages)


If you choose no, the above packages will not be installed and this script
will exit. This gives you a chance to edit the list of packages if you want
to adjust them

EOF

  while true; do
    read -rp "Do you want to install the above packages? (y/n) " yn
    case "${yn}" in
    [Yy]*)
      if [ "${OS_TYPE}" == "linux" ]; then
        if [ "${OS_DISTRO}" == "arch" ]; then
          _install_packages_arch
        elif [ "${OS_DISTRO}" == "debian" ]; then
          _install_packages_debian
        fi
      else
        _install_packages_macos
      fi

      break
      ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

clone_dotfiles() {
  _info "CLONE DOTFILES"

  if [ -d "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since DOTFILES_PATH already exists at '${DOTFILES_PATH}'"
    return 0
  fi

  local default_dotfiles_path="${HOME}/dotfiles"

  # Detect non-interactive mode (no TTY = piped input like `yes |`)
  if [[ "$NON_INTERACTIVE" == "true" ]]; then
    dotfiles_path="${default_dotfiles_path}"
    echo "Detected non-interactive mode, using default DOTFILES_PATH: ${default_dotfiles_path}"
  else
    read -rep "Where do you want to clone these dotfiles to [${default_dotfiles_path}]? " dotfiles_path
    echo
  fi

  [[ -z "${dotfiles_path}" ]] && dotfiles_path="${default_dotfiles_path}"

  DOTFILES_PATH="${dotfiles_path//\~/"${HOME}"}"

  _local_only && return 0

  git clone "${DOTFILES_URL}" "${DOTFILES_PATH}"
}

install_zsh_plugins() {
  _info "INSTALL ZSH PLUGINS"

  "${DOTFILES_PATH}/.local/bin/update-zsh-plugins"
}

create_symlinks() {
  _info "CREATE SYMLINKS"

  local symlinks=(
    "${DOTFILES_PATH}/.zshenv ${HOME}/.zshenv"
    "${DOTFILES_PATH}/.config/zsh/.zshrc ${HOME}/.config/zsh/.zshrc"
    "${DOTFILES_PATH}/.config/zsh/.zshrc.local ${HOME}/.config/zsh/.zshrc.local"
    "${DOTFILES_PATH}/.config/zsh/.zprofile ${HOME}/.config/zsh/.zprofile"
    "${DOTFILES_PATH}/.config/zsh/.zprofile.local ${HOME}/.config/zsh/.zprofile.local"
    "${DOTFILES_PATH}/.config/zsh/.aliases ${HOME}/.config/zsh/.aliases"
    "${DOTFILES_PATH}/.config/zsh/.aliases.local ${HOME}/.config/zsh/.aliases.local"
    "${DOTFILES_PATH}/.config/wezterm/wezterm.lua ${HOME}/.config/wezterm/wezterm.lua"
    "${DOTFILES_PATH}/.config/tmux/tmux.conf ${HOME}/.config/tmux/tmux.conf"
    "${DOTFILES_PATH}/.config/zsh/themes ${HOME}/.config/zsh/themes"
    "${DOTFILES_PATH}/.config/tmux/themes ${HOME}/.config/tmux/themes"
    "${DOTFILES_PATH}/.config/bat/themes ${HOME}/.config/bat/themes"
    "${DOTFILES_PATH}/.config/git/config ${HOME}/.config/git/config"
    "${DOTFILES_PATH}/.config/git/config.local ${HOME}/.config/git/config.local"
    "${DOTFILES_PATH}/.config/gitui ${HOME}/.config/gitui"
    "${DOTFILES_PATH}/.config/nvim ${HOME}/.config/nvim"
    "${DOTFILES_PATH}/.local/bin/* ${HOME}/.local/bin"
  )

  local symlinks_system=()

  # And if you happen to be using WSL:
  if [ -n "${OS_IN_WSL}" ]; then
    symlinks_system+=(
      "${DOTFILES_PATH}/etc/wsl.conf /etc/wsl.conf"
    )
    for user_path in $(_get_win_users_path); do
      cp "${DOTFILES_PATH}/.config/wezterm/wezterm.lua" "${user_path}/.wezterm.lua"
      echo "Copied wezterm.lua to window users"
    done
  fi

  if [ "${OS_DISTRO}" = "arch" ]; then
    symlinks_system+=("${DOTFILES_PATH}/etc/pacman.d/01-options.conf /etc/pacman.d/01-options.conf")

    if [ -f "etc/pacman.d/02-ignore.conf" ]; then
      symlinks_system+=("${DOTFILES_PATH}/etc/pacman.d/02-ignore.conf /etc/pacman.d/02-ignore.conf")
    else
      sudo rm -f "/etc/pacman.d/02-ignore.conf"
    fi
  fi

  cat <<EOF

  -----------------------------------------------------------------------------------
  The following symlinks will be created:
  -----------------------------------------------------------------------------------

EOF

  while true; do
    read -rep "Ready to continue? Enter y to apply them all or n to skip (y/n) " yn
    case "${yn}" in
    [Yy]*)
      # Avoid using ln -T flag since it doesn't exist on macOS. We're being
      # extra careful here to only delete symlinks if they exist. Technically
      # rm -f would work but that could delete real files potentially.
      [ -L "${HOME}/.config/zsh/themes" ] && rm "${HOME}/.config/zsh/themes"
      [ -L "${HOME}/.config/tmux/themes" ] && rm "${HOME}/.config/tmux/themes"
      [ -L "${HOME}/.config/bat/themes" ] && rm "${HOME}/.config/bat/themes"
      [ -L "${HOME}/.config/gitui" ] && rm "${HOME}/.config/gitui"
      [ -L "${HOME}/.config/nvim" ] && rm "${HOME}/.config/nvim"

      # Backup and create symlinks for each file
      for link in "${symlinks[@]}"; do
        read -r src dest <<<"$link"
        _backup_and_symlink "$src" "$dest"
      done

      for link in "${symlinks_system[@]}"; do
        read -r src dest <<<"$link"
        _backup_and_symlink "$src" "$dest" sudo
      done

      echo "🌟 All symlinks created successfully."

      break
      ;;
    [Nn]*)

      break
      ;;
    *) echo "Please answer y or n" ;;
    esac
  done
}

configure_system_configs() {
  _info "CONFIGURE SYSTEM CONFIGS"

  if [ "${OS_DISTRO}" = "arch" ]; then
    local etc_pacman_conf_path="/etc/pacman.conf"
    if ! grep -q "Include = /etc/pacman\.d/\*\.conf" "${etc_pacman_conf_path}" 2>/dev/null; then
      printf "\nInclude = /etc/pacman.d/*.conf\n" | sudo tee --append "${etc_pacman_conf_path}" 1>/dev/null
    fi
  fi

  echo "Everything that required updating was updated"
}

configure_shell() {
  _info "CONFIGURE SHELL (ZSH)"

  local local_files=(".zshrc.local" ".zprofile.local" ".aliases.local")
  local original_dotfiles_path="${DOTFILES_PATH}"

  for file in "${local_files[@]}"; do
    local file_path="${HOME}/.config/zsh/${file}"

    if [ ! -f "${file_path}" ]; then
      printf "# shellcheck shell=bash\n\n# Any settings defined here are gitignored\n" >"${file_path}"
    fi
  done

  local zprofile_path="${DOTFILES_PATH}/.config/zsh/.zprofile.local"

  if ! grep -q "^export DOTFILES_PATH=.*$" "${zprofile_path}" 2>/dev/null; then
    printf '\nexport DOTFILES_PATH="%s"\n' "${DOTFILES_PATH}" >>"${zprofile_path}"
  fi

  if [ "${OS_TYPE}" == "darwin" ]; then
    if ! grep -q "HOMEBREW_NO_ANALYTICS" "${zprofile_path}" 2>/dev/null; then
      printf '\nexport HOMEBREW_NO_ANALYTICS=1\n' >>"${zprofile_path}"
    fi

    if ! grep -q "eval.*homebrew.*shellenv" "${zprofile_path}" 2>/dev/null; then
      local prefix="/opt/homebrew"
      [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"
      # shellcheck disable=SC2016
      printf "\neval \"\$(%s/bin/brew shellenv)\"\n" "${prefix}" >>"${zprofile_path}"
    fi
  else
    # Are we in WSL 2?
    if [ -n "${OS_IN_WSL}" ]; then
      # This only applies if you have Docker installed without Docker Desktop
      # and you're not using systemd.
      if command -v docker &>/dev/null; then
        if [ ! -d "${HOME}/.docker/desktop" ]; then
          if [ ! -d /run/systemd/system ]; then
            if ! grep -q "^if service docker status.*$" "${zprofile_path}" 2>/dev/null; then
              local docker=
              docker=$(
                cat <<'EOF'
# Ensure Docker is running on WSL 2. This expects you've installed Docker and
# Docker Compose directly within your WSL distro instead of Docker Desktop.
#   - https://nickjanetakis.com/blog/install-docker-in-wsl-2-without-docker-desktop
if service docker status 2>&1 | grep -q "is not running"; then
  wsl.exe --distribution "${WSL_DISTRO_NAME}" --user root \
    --exec /usr/sbin/service docker start &> /dev/null
fi
EOF
              )

              printf "\n\n%s" "${docker}" >>"${zprofile_path}"
            fi
          fi
        fi
      fi
    fi

    # This should happen on all Linux distros.
    [ "${SHELL: -3}" != "zsh" ] && chsh -s "/usr/bin/zsh"
  fi

  # shellcheck disable=SC1091
  . "${HOME}/.config/zsh/.zprofile"

  # Given the above line sets this env var if it's defined, this ensures we
  # always use the value that was set when running this script. This is mainly
  # to make testing this script easier in Docker since the .local files are
  # volume mounted and this value will be different in Docker.
  DOTFILES_PATH="${original_dotfiles_path}"

  echo "It has been configured in '${HOME}/.config/zsh/'"
}

install_mise_packages() {
  _info "INSTALL MISE PACKAGES"
  # Install Mise packages.

  # Apt's packages typically have older versions since Debian and Ubuntu are
  # stable distros. In most cases the version included is fine but we do want
  # the latest and greatest versions for certain tools.
  echo
  # shellcheck disable=SC2086
  if [[ -n "${MISE_PACKAGES_DEBIAN}" ]]; then
    for package in ${MISE_PACKAGES_DEBIAN}; do
      mise use --global "$package@latest"
      sleep 1
    done
  elif [[ -n "${MISE_PACKAGES_ARCH}" ]]; then
    for package in ${MISE_PACKAGES_ARCH}; do
      mise use --global "$package@latest"
      sleep 1
    done
  elif [[ -n "${MISE_PACKAGES_BREW}" ]]; then
    for package in ${MISE_PACKAGES_BREW}; do
      mise use --global "$package@latest"
      sleep 1
    done
  fi

  bat cache --build
  sleep 5
}

install_programming_languages() {
  _info "INSTALL PROGRAMMING LANGUAGES"

  for lang in "${!MISE_LANGUAGES[@]}"; do
    # Prevent github secondary rate limit from kicking in
    sleep 3

    [ -z "${MISE_LANGUAGES[${lang}]}" ] && continue

    printf "\nInstalling %s...\n\n" "${MISE_LANGUAGES[${lang}]}"
    if command -v "${HOME}/.local/share/mise/shims/${lang}" 1>/dev/null; then
      echo "Skipping, it's already installed, run 'mise upgrade ${lang} --bump' to upgrade"
    else
      mise use --global "${MISE_LANGUAGES[${lang}]}"
    fi

    # Also install Yarn for Node.
    if [ "${lang}" = "node" ]; then
      if ! yarn --version >/dev/null 2>&1; then
        npm install --unsafe-perm=true --allow-root --global yarn
      fi
    fi
  done
}

install_tools_with_python() {
  _info "INSTALLING TOOLS WITH PYTHON PIP"

  pip install --upgrade pip

  # tldr
  pip install --user tldr
  printf "Installing latest tldr (better man) ... \n\n"

  # autocorrect previous command that entered wrongly
  #pip3 install thefuck --user
  #printf("Installing latest thefuck (autocorrect prompt) ... \n\n"

  # for neovim
  pip install --user pynvim
}

ask_for_name() {
  _info "ASKING FOR YOUR NAME TO CONFIGURE GIT"

  local name=

  set +o errexit
  name="$(git config user.name)"
  set -o errexit

  if [[ -n "${name}" ]]; then
    echo "Skipping, since '${name}' was retrieved from your git config"
  else
    if [[ "$NON_INTERACTIVE" == "true" ]]; then
      # Non-interactive mode (e.g., yes | bash install)
      name="Default User"
      echo "Non-interactive mode detected. Using default name: '${name}'"
    else
      while true; do
        printf "What is your full name (ie. Dade Murphy)? "
        read -r name

        if [[ ${name} =~ [^[:space:]]+ ]]; then
          break
        else
          printf "Please enter at least your first name\n\n"
        fi
      done
    fi
  fi

  NAME="${name}"
}

ask_for_email() {
  _info "ASKING FOR YOUR EMAIL TO CONFIGURE GIT"

  local email=

  set +o errexit
  email="$(git config user.email)"
  set -o errexit

  if [[ -n "${email}" ]]; then
    echo "Skipping, since '${email}' was retrieved from your git config"
  else
    if [[ "$NON_INTERACTIVE" == "true" ]]; then
      # Non-interactive mode (e.g., yes | bash install)
      email="default@example.com"
      echo "Non-interactive mode detected. Using default email: '${email}'"
    else
      while true; do
        printf "What is your email (ie. crash.override@example.com)? "
        read -r email

        if [[ ${email} =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
          break
        else
          printf "Please enter a valid email address\n\n"
        fi
      done
    fi
  fi

  EMAIL="${email}"
}

create_ssh_key() {
  _info "CREATING SSH KEY"

  local -r key_path="${HOME}/.ssh/id_ed25519"

  if [[ -f "${key_path}" ]]; then
    echo "Skipping, since a key already exists at '${key_path}'"
  else
    ssh-keygen -t ed25519 -C "${EMAIL}" -N "" -f "${key_path}"
  fi

  eval "$(ssh-agent -s)"
  ssh-add "${key_path}"

  SSH_PUBKEY=$(<"${key_path}.pub")

  SSH_INSTRUCTIONS=$(
    cat <<EOF
# ==============================================================================
# 🔐 SSH Key Generated!
# ------------------------------------------------------------------------------
# To enable SSH access to GitHub, GitLab, or other Git servers:
#
# ➤ 1. Copy your public SSH key from above:
#
# ➤ 2. Go to your Git hosting account and add it:
#
#    • GitHub:
#        https://github.com/settings/ssh/new
#
#    • GitLab:
#        https://gitlab.com/-/profile/keys
#
# ➤ 3. Paste the key and give it a descriptive title (e.g. "dev laptop")
#
# ✅ You can now clone and push via SSH! Example:
#     git clone git@github.com:user/repo.git
# ==============================================================================
EOF
  )
}

create_gpg_key() {
  _info "CREATING GPG KEY"

  local gpg_home="${GNUPGHOME:-"${HOME}/.gnupg"}"
  local gpg_key=

  set +o errexit
  gpg_key="$(gpg --export --armor "${EMAIL}" 2>/dev/null)"
  set -o errexit

  if [[ "${gpg_key}" =~ "PGP PUBLIC KEY" ]]; then
    echo "Skipping, since a key already exists for '${EMAIL}'"
  else
    mkdir -p "${gpg_home}"
    chmod 700 "${gpg_home}"

    while true; do
      printf "Please set a passphrase (password) for your key: "
      read -sr passphrase

      if [[ ! ${passphrase} =~ [^[:space:]]+ ]]; then
        printf "\nPlease enter at least 1 non-space character\n\n"
        continue
      fi

      printf "\n\nPlease confirm your passphrase: "
      read -sr passphrase_confirm

      [ "${passphrase}" = "${passphrase_confirm}" ] && break

      printf "\nYour passphrase did not match, please try again\n\n"
    done

    printf "\n\nGenerating GPG key...\n\n"

    gpg --batch --pinentry-mode loopback --gen-key <<EOF
     Key-Type: RSA
     Key-Length: 4096
     Subkey-Type: RSA
     Subkey-Length: 4096
     Name-Real: ${NAME}
     Name-Email: ${EMAIL}
     Passphrase: ${passphrase}
     Expire-Date: 1y
EOF

    gpg_key="$(gpg --export --armor "${EMAIL}" 2>/dev/null)"
  fi

  GPG_PUBKEY="${gpg_key}"

  GPG_INSTRUCTIONS=$(
    cat <<EOF
# ==============================================================================
# 🛡️  Git Commit Signing with GPG: One More Step!
# ------------------------------------------------------------------------------
# To make your signed commits show up as "Verified" on GitHub or GitLab,
# you need to upload your GPG public key as shown above to your account.
#
# ➤ 1. Copy the full key block, including:
#     -----BEGIN PGP PUBLIC KEY BLOCK-----
#     ...
#     -----END PGP PUBLIC KEY BLOCK-----
#
# ➤ 2. Add the key on GitHub:
#     https://github.com/settings/keys → New GPG key
#
# ✅ After that, your signed commits will be marked as Verified!
# ==============================================================================
EOF
  )
}

configure_git() {
  _info "CONFIGURING GIT TO SIGN COMMITS"

  local gpg_fingerprint
  gpg_fingerprint=$(gpg --list-keys --with-colons "${EMAIL}" | awk -F: '/^fpr:/ { print $10; exit }')

  local git_config_local_path="${DOTFILES_PATH}/.config/git/config.local"

  if [ ! -f "${git_config_local_path}" ]; then
    cat <<EOF >"${git_config_local_path}"
[user]
  name = ${NAME}
  email = ${EMAIL}
  signingkey = ${gpg_fingerprint}

# Learn more about signing git commits here:
#   https://nickjanetakis.com/blog/signing-and-verifying-git-commits-on-the-command-line-and-github

# Uncomment the options below to auto-sign your git commits / tags using GPG.
#[commit]
#  gpgsign = true

# This option requires git 2.23+ to work and you must annotate your tags,
# although -m "" works if you want an empty message.
#[tag]
#  gpgSign = true

#[gpg]
#  program = gpg
EOF
  fi
  echo "It has been configured in '$(dirname "${git_config_local_path}")'"
  echo "✅ Git is now set to sign commits using your GPG key. Uncomment them to use it"
  echo "🔑 GPG Fingerprint: ${gpg_fingerprint}"
}

install_tmux_plugins() {
  _info "INSTALL TMUX PLUGINS"

  local plugin_path="${HOME}/.config/tmux/plugins"
  local tpm_path="${plugin_path}/tpm"

  rm -rf "${tpm_path}"
  git clone --depth 1 https://github.com/tmux-plugins/tpm "${tpm_path}"

  "${tpm_path}/bin/install_plugins"
}

install_nvim_plugins() {
  _info "INSTALL NEOVIM PLUGINS"

  nvim +q

  echo "They've been installed"
}

install_powerlevel10k() {
  _info "INSTALL POWERLEVEL10K"

  if [ ! -d "${HOME}/powerlevel10k" ]; then
    git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "${HOME}/powerlevel10k"
  else
    echo "✅ powerlevel10k already exists, skipping clone."
  fi
}

install_nerdfont() {
  _info "INSTALL NERDFONT"

  local font_dir="$HOME/.local/share/fonts"
  local meslo_pattern="MesloLGS NF*"

  # Check if any Meslo Nerd Font files exist
  if ! find "$font_dir" -type f -iname "$meslo_pattern" | grep -q .; then
    echo "🔤 Meslo Nerd Font not found, downloading..."
    wget -O /tmp/Meslo.zip "https://github.com/ryanoasis/nerd-fonts/releases/download/v3.3.0/Meslo.zip"
    unzip -o /tmp/Meslo.zip -d "$font_dir"
  else
    echo "✅ Meslo Nerd Font already installed."
  fi
  fc-cache -fv
}

healthcheck() {
  _info "CHECK INFORMATION AND VERSIONS"

  cat <<EOF
:: Dotfiles path:

${DOTFILES_PATH}

:: Git user:

$(git config --get-regex "user.(name|email)")

:: tmux:

$(tmux -V)

:: Neovim:

$(nvim --version)

:: Fastfetch:

EOF

  fastfetch
}

completed_message() {
  _info "SHOWING SSH PUBKEY"
  echo "$SSH_PUBKEY"
  echo
  echo "$SSH_INSTRUCTIONS"

  _info "SHOWING GPG PUBKEY"
  echo "$GPG_PUBKEY"
  echo
  echo "$GPG_INSTRUCTIONS"

  _info "EVERYTHING WORKED"

  cat <<EOF
You can safely close this terminal.

The next time you open your terminal everything will be ready to go!
EOF

  if [ "${OS_TYPE}" == "darwin" ]; then
    cat <<EOF

P.S., it looks like you're on macOS.

If you're using iTerm2 as your terminal you'll want to goto Settings ->
Profiles -> Keys (tab) and then change your ALT keys to use "Esc+" instead of
"Normal", otherwise ALT+x keymaps in Neovim may not work.

If you're not using iTerm2 you may still need to do similar steps.
EOF
  fi
}

case "${1:-}" in
--update | -u)
  ONLY_UPDATE=1
  ;;
--skip-system-packages | -S) ;;
--help | -h)
  cat <<EOF
Usage examples:

# Pull in remote updates and run the script to update your dotfiles.
./install

# Only pull in remote updates and exit early.
./install --update

# Update your dotfiles with whatever version of this script that exists locally.
LOCAL=1 ./install

# Show this help menu.
./install --help
EOF
  exit
  ;;
*)
  [ -n "${1:-}" ] && _error "'${1}' is not a supported flag"

  ;;
esac

detect_env
warn_root
update_dotfiles "${@}" && [ -n "${ONLY_UPDATE}" ] && exit
check_prereqs
create_initial_dirs
install_packages
clone_dotfiles
install_zsh_plugins
create_symlinks
configure_system_configs
configure_shell
ask_for_name
ask_for_email
create_ssh_key
create_gpg_key
configure_git
install_mise_packages
install_programming_languages
install_tools_with_python
install_tmux_plugins
install_nvim_plugins
install_powerlevel10k
install_nerdfont
healthcheck
completed_message
